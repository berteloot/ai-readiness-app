// PDFGenerator.tsx
// Requires: npm i jspdf
import React from 'react';
import { jsPDF } from 'jspdf';

type ScoreItem = {
  key: string;           // e.g., "s1"
  label: string;         // e.g., "Data Infrastructure"
  score: number;         // e.g., 6
  max: number;           // e.g., 10
  note?: string;         // optional short note for the row
};

export type ReportData = {
  company?: string;
  dateISO?: string;      // if omitted, uses today's date
  score: number;         // overall score
  maxScore: number;      // overall max
  summary: string;       // the AI-produced "Executive Summary" text
  items: ScoreItem[];    // breakdown rows
  orderedKeys?: string[]; // optional: enforce row order by keys
};

const A4 = { width: 595.28, height: 841.89 }; // jsPDF's default pt size for A4

/**
 * Generate the AI Readiness PDF and trigger a download.
 */
export function generateAIReadinessPDF(data: ReportData, filename = 'AI-Readiness-Report.pdf') {
  const doc = new jsPDF({ unit: 'pt', format: 'a4' });
  const margin = 56; // 0.78 in
  const pageWidth = A4.width;
  const pageHeight = A4.height;
  const contentWidth = pageWidth - margin * 2;

  let y = margin + 44; // start below header area

  // Helpers
  const setFont = (size: number, style: 'normal' | 'bold' = 'normal') => {
    doc.setFont('helvetica', style);
    doc.setFontSize(size);
    doc.setTextColor(17, 24, 39); // gray-900
  };

  const addPageIfNeeded = (needed: number, resetY = margin + 44) => {
    if (y + needed > pageHeight - margin) {
      doc.addPage();
      drawHeaderBand();
      y = resetY;
    }
  };

  const drawHeaderBand = () => {
    // Top title band
    doc.setFillColor(243, 244, 246); // gray-100
    doc.rect(0, 0, pageWidth, 90, 'F');

    // Title
    setFont(18, 'bold');
    doc.setTextColor(37, 99, 235); // blue-600
    doc.text('AI Readiness Assessment Report', margin, 50);

    // Right header block: company and date
    setFont(10, 'normal');
    doc.setTextColor(107, 114, 128); // gray-500
    const date = data.dateISO ? new Date(data.dateISO) : new Date();
    const dateStr = date.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });

    const rightX = pageWidth - margin;
    const companyLines = doc.splitTextToSize(data.company || 'Your Company', 220);
    doc.text('Company', rightX, 28, { align: 'right' });
    doc.setTextColor(17, 24, 39);
    doc.text(companyLines, rightX, 44, { align: 'right' });

    doc.setTextColor(107, 114, 128);
    doc.text('Date', rightX, 64 + companyLines.length * 12, { align: 'right' });
    doc.setTextColor(17, 24, 39);
    doc.text(dateStr, rightX, 80 + companyLines.length * 12, { align: 'right' });
  };

  const drawFooterAllPages = () => {
    const pages = doc.getNumberOfPages();
    for (let i = 1; i <= pages; i++) {
      doc.setPage(i);
      const footerY = pageHeight - 40;
      doc.setDrawColor(229, 231, 235); // gray-200
      doc.line(margin, footerY, pageWidth - margin, footerY);
      setFont(9, 'normal');
      doc.setTextColor(107, 114, 128); // gray-500
      doc.text('Generated by Lean Solutions Group', pageWidth / 2, footerY + 14, { align: 'center' });
      doc.text(`AI Readiness Assessment Tool  â€¢  ${i}/${pages}`, pageWidth / 2, footerY + 28, { align: 'center' });
    }
  };

  // Sanitizer for LLM summary to avoid duplicate headings and wrong denominators
  const sanitizeAiReport = (txt: string, score: number, maxScore: number) => {
    let out = txt || '';
    out = out.replace(/^AI Readiness Assessment Report\s*\n*/i, '');
    out = out.replace(/^Executive Summary\s*\n*/i, '');
    // normalize any "X of N" or "X/N" after an "Overall" or "Numeric" cue
    out = out.replace(/(\bOverall AI Readiness Score:\s*)(\d+)\s*(?:of|\/)\s*\d+/i, `$1${score} of ${maxScore}`);
    out = out.replace(/(\bNumeric Score:\s*)(\d+)\b[^\n]*/i, `$1${score}`);
    return out.trim();
  };

  // Bold-aware, newline-aware wrapped line drawer. Returns next y baseline.
  const drawRichLine = (str: string, baseLeft = margin, firstLineIndent = 0) => {
    const left = baseLeft;
    const right = margin + contentWidth;
    let x = left + firstLineIndent;
    let baseline = y;

    const tokens = (str || '').split(/(\*\*.*?\*\*)/).filter(Boolean);
    const pushWord = (word: string, bold: boolean) => {
      const w = doc.getTextWidth(word + ' ');
      if (x + w > right) {
        x = left;
        baseline += 14;
        if (baseline > pageHeight - margin - 40) {
          doc.addPage(); drawHeaderBand(); baseline = margin + 44;
        }
      }
      doc.setFont('helvetica', bold ? 'bold' : 'normal');
      doc.text(word + ' ', x, baseline);
      x += w;
    };

    tokens.forEach(tok => {
      const isBold = tok.startsWith('**') && tok.endsWith('**');
      const text = isBold ? tok.slice(2, -2) : tok;

      const lines = text.split(/\n/);
      lines.forEach((line, i) => {
        line.split(/\s+/).forEach(word => { if (word) pushWord(word, isBold); });
        if (i < lines.length - 1) {
          x = left;
          baseline += 14;
          if (baseline > pageHeight - margin - 40) {
            doc.addPage(); drawHeaderBand(); baseline = margin + 44;
          }
        }
      });
    });

    y = baseline + 16;
  };

  const drawParagraphs = (text: string) => {
    const paras = (text || '').split(/\n\s*\n/).filter(p => p.trim());
    paras.forEach((p, i) => {
      addPageIfNeeded(40);
      drawRichLine(p);
      if (i < paras.length - 1) y += 2;
    });
  };

  const drawSectionHeading = (label: string) => {
    addPageIfNeeded(48);
    doc.setFillColor(239, 246, 255); // blue-50
    doc.roundedRect(margin, y - 22, contentWidth, 34, 8, 8, 'F');
    setFont(13, 'bold');
    doc.setTextColor(37, 99, 235);
    doc.text(label, margin + 14, y);
    y += 18;
    setFont(11, 'normal');
    doc.setTextColor(17, 24, 39);
  };

  const drawScoreHeader = () => {
    addPageIfNeeded(70);
    // Score card row
    const cardH = 70;
    const cardW = (contentWidth - 12) / 2;

    // Overall score card
    doc.setFillColor(245, 245, 245);
    doc.roundedRect(margin, y, cardW, cardH, 10, 10, 'F');
    setFont(12, 'bold');
    doc.setTextColor(37, 99, 235);
    doc.text('Overall Score', margin + 16, y + 24);
    setFont(24, 'bold');
    doc.setTextColor(17, 24, 39);
    doc.text(`${data.score} / ${data.maxScore}`, margin + 16, y + 52);

    // Interpretation card
    doc.setFillColor(250, 250, 250);
    doc.roundedRect(margin + cardW + 12, y, cardW, cardH, 10, 10, 'F');
    setFont(12, 'bold');
    doc.setTextColor(107, 114, 128);
    doc.text('Interpretation', margin + cardW + 28, y + 24);
    setFont(11, 'normal');
    doc.setTextColor(17, 24, 39);
    doc.text('See Executive Summary below for plain-English guidance.', margin + cardW + 28, y + 46);

    y += cardH + 20;
  };

  const drawScoreBreakdown = () => {
    if (!data.items?.length) return;

    // Enforce row order if provided, else use insertion order
    const keyOrder = data.orderedKeys?.length
      ? data.orderedKeys.filter(k => data.items.some(i => i.key === k))
      : data.items.map(i => i.key);

    const items = keyOrder.map(k => data.items.find(i => i.key === k)!).filter(Boolean);

    // Pre-calc row heights with wrapped labels
    const leftX = margin + 16;
    const nameColWidth = contentWidth - 140; // space for score column
    const rowHeights: number[] = [];
    const wrappedNames: string[][] = [];

    items.forEach(it => {
      const lines = doc.splitTextToSize(it.label, nameColWidth);
      wrappedNames.push(lines);
      const lineBlock = Math.max(1, lines.length);
      const h = 18 + (lineBlock - 1) * 12;
      rowHeights.push(h);
    });

    const headerH = 36;
    const padding = 22;
    const boxHeight = padding + headerH + rowHeights.reduce((a, b) => a + b, 0) + padding;

    // Page guard for entire box
    addPageIfNeeded(boxHeight);

    // Box
    doc.setFillColor(255, 255, 255);
    doc.setDrawColor(229, 231, 235);
    doc.roundedRect(margin, y, contentWidth, boxHeight, 10, 10, 'FD');

    // Title
    setFont(12, 'bold');
    doc.setTextColor(17, 24, 39);
    doc.text('Score Breakdown', margin + 16, y + 22);

    // Header row
    const tableTop = y + padding + 6;
    setFont(10, 'bold');
    doc.setTextColor(107, 114, 128);
    doc.text('Section', leftX, tableTop);
    doc.text('Score', margin + contentWidth - 22, tableTop, { align: 'right' });

    let rowY = tableTop + 14;
    setFont(11, 'normal');
    doc.setTextColor(17, 24, 39);

    // Rows
    items.forEach((it, idx) => {
      const h = rowHeights[idx];
      // row divider
      doc.setDrawColor(243, 244, 246);
      doc.line(margin + 10, rowY - 10, margin + contentWidth - 10, rowY - 10);

      // name
      const lines = wrappedNames[idx];
      lines.forEach((ln, li) => {
        doc.text(ln, leftX, rowY + li * 12);
      });

      // score right aligned
      setFont(11, 'bold');
      doc.setTextColor(37, 99, 235);
      doc.text(`${it.score}/${it.max}`, margin + contentWidth - 22, rowY, { align: 'right' });
      setFont(11, 'normal');
      doc.setTextColor(17, 24, 39);

      rowY += h;
    });

    y += boxHeight + 18;
  };

  // Draw
  drawHeaderBand();
  drawScoreHeader();

  // Executive Summary section
  drawSectionHeading('Executive Summary');
  const cleanSummary = sanitizeAiReport(data.summary, data.score, data.maxScore);
  drawParagraphs(cleanSummary);

  // Breakdown section
  drawSectionHeading('Detailed Scores');
  drawScoreBreakdown();

  // Footer on every page
  drawFooterAllPages();

  // Save
  doc.save(filename);
}

/**
 * Optional React button wrapper.
 * Use: <PDFButton data={...} />
 */
export const PDFButton: React.FC<{ data: ReportData; filename?: string; className?: string }> = ({
  data,
  filename = 'AI-Readiness-Report.pdf',
  className,
}) => {
  const handleClick = () => generateAIReadinessPDF(data, filename);
  return (
    <button onClick={handleClick} className={className}>
      Download AI Readiness Report (PDF)
    </button>
  );
};
